 # 基础篇

1. 面向对象的特征：继承、封装和多态

封装 ： 是指把对象的属性以及实现细节隐藏起来，仅对外提供公共的访问方法

- 好处：提高代码模块的安全性，将变化隔离，提高可重用性（对外提供可调用的公共方法，内部实现可以灵活处理）

封装的原则：

- 将不需要对外提供的属性方法隐藏
- 把属性隐藏，仅仅提供公共方法对其访问

继承：继承是一种联结类的层次模型，运行类的重用，java提供的一种重用的具体实现，对象的一个新的类可以从现有的类中派生，这个过程叫继承

- 好处：继承提高了代码的复用性、继承让类与类之间产生关系，提供了多态的前提
- 继承的特点：一个类只可以继承一个父类，一个父类可以被任意多个子类继承

多态：发送消息给某个对象，让对象自行决定响应何种行为，通过子类对象引用赋值给超类对象引用来实现动态方法调用。

- 多态的表现形式:
  - 重写：重写发生于子类继承父类，子类可以重写父类的方法，实例对象调用该方法时，调用优先调用子类的该方法
  - 重载：重载发生于一个类中，存在多个同名的方法，方法的参数不同，实例对象传入不同的参数，对象根据传入的引用动态决定调用哪个方法。

2.  final, finally, finalize 的区别

finall修饰符（关键字）。被final修饰的类，就意味着不能再派生出新的子类，不能作为父类而被子类继承。因此一个类不能既被abstract声明，又被final声明。将变量或方法声明为final，可以保证他们在使用的过程中不被修改。被声明为final的变量必须在声明时给出变量的初始值，而在以后的引用中只能读取。被final声明的方法也同样只能使用，即不能方法重写。

finally:是在异常处理时提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获，finally块都会被执行。try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。finally块则是无论异常是否发生，都会执行finally块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在finally块中

finalize是方法名:java技术允许使用finalize（）方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在object类中定义的，因此所有的类都继承了它。子类覆盖finalize（）方法以整理系统资源或者被执行其他清理工作。finalize（）方法是在垃圾收集器删除对象之前对这个对象调用的。 

3. Exception、Error、运行时异常与一般异常有何异同

   Error:表示有JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误，导致JVM无法正常进行执行。因此是不可捕获的，也无法采取任何恢复的操作。顶多只能显示错误的信息。

   Exception :表示可恢复的异常，这是可以捕获的。

   Exception 在java中分为runtime exception和checked exception. checked异常是我们经常遇到的IO异常，SQL异常，对应这种异常JAVA编译器强制要求用户对这种异常进程catch.所以。面对这种异常不管我们愿不愿意都必须写一堆catch块去处理有可能出现的异常.这类异常一般都是外部错误。例如试图从文件尾后读取数据等,这并不是程序本身的错误,而是在应用环境中出现的外部错误.

   另一种是runtime exception 也称为运行时异常。我们可以不去处理，但出现异常时，jvm会去处理它。比如：我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。RuntimeException体系包括错误的类型转换、数组越界访问和试图访问空指针等等.处理RuntimeException的原则是:假如出现RuntimeException,那么一定是程序员的错误.例如,可以通过检查数组下标和数组边界来避免数组越界访问异常.

   **异常处理的目标之一就是为了把程序从异常中恢复出来**

4. 请写出5种常见到的runtime exception

   NullPointerException(空指针异常)、ClassCastException（类型强制转换异常）

   IllegalArgumentException (传递参数异常) ArithemeticExcetion （算术运算异常）

   ArrayStoreException (数据存放于声明类型不兼容异常)、IndexOutOfBoundExceptin(下标越界异常)、NegativeArraySizeExcetion(创建一个大小为负数的数组异常)、NumberFormatException(数字格式异常)、SecurityException(安全异常) UnsupportedOperationExcetion(不支持的操作异常)

5. int 和 Integer 有什么区别，Integer的值缓存范围

int 是基本类型，存储是数值，默认值为0，Integer是对象，默认值为null。int的值赋值给Integer会自动装箱，Integer类型赋值给int 型会自动拆箱。Integer与int 用等号比较会自动拆箱比较。

Integer的值范围缓存是-128~127

6. ·      String、StringBuilder、StringBuffer

   StringBuilder是线程不安全的，而StringBuffer是线程安全的

   String是不可变的，String 中的拼接字符串或者减少是字符串底层调用StringBuilder来进行

7. 重载和重写的区别

   - 多态的表现形式:
     - 重写：重写发生于子类继承父类，子类可以重写父类的方法，实例对象调用该方法时，调用优先调用子类的该方法
     - 重载：重载发生于一个类中，存在多个同名的方法，方法的参数不同，实例对象传入不同的参数，对象根据传入的引用动态决定调用哪个方法。

8. 抽象类和接口有什么区别

   接口和抽象类都不能被实例化，只能被子类实现或者继承

   接口和抽象类都可以包含抽象方法，实现接口或者继承抽象类需要实现对应的抽象方法

   jdk 1.8可以有被静态static修饰的方法的实现。或者default修饰

   区别：

   1.接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供方法实现，抽象类则完全可以包含普通方法。

   2.接口里只能定义静态常量，不能定义普通成员变量，抽象类里则既可以定义普通成员变量，也可以定义静态常量。

   3.接口不能包含构造器，抽象类可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。

   4.接口里不能包含初始化块，但抽象类里完全可以包含初始化块

   5.一个类最多只能有一个直接父类，包括抽象类，但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承不足。

9. 说说反射的用途及实现

   通过反射可以在程序运行时，获得类的成员变量，方法，类信息。

   程序中一般的对象类型都是在编译期就确定下来的，而Java 反射机制可以动态的创建对象并调用其属性，这样对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象即使这个对象在编译期是未知的，
    反射的核心：是 JVM 在运行时 才动态加载的类或调用方法或属性，他不需要事先（写代码的时候或编译期）知道运行对象是谁。

   当我们在使用 IDE（如 Eclipse\IDEA）时，当我们输入一个队长或者类并向调用它的属性和方法时，一按 (“.”)点号，编译器就会自动列出她的属性或方法，这里就会用到反射。

   ###### 反射最重要的用途就是开发各种通用框架。

   很多框架（比如 Spring）都是配置化的（比如通过 XML文件配置 JavaBean，Action之类的），为了保证框架的通用性，他们可能根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。

   反射的基本运用：

   > ①、获得 Class 对象
   >
   > > （1）、使用 Class类的 forName() 静态方法：
   > >  public static Class<?> forName(String className)
   > >  ……
   > >  在JDBC开发中常用此方法加载数据库驱动:
   > >  ……java
   > >  Class.forName(driver)
   > >  （2）、直接获取某一个对象的 class，比如：
   > >  Class<?> klass = int.class;
   > >  Class<?> classInt = Integer.TYPE;
   > >  （3）、调用某个对象的getClass() 方法，比如：
   > >  StringBuilder str = new StringBuilder("123");
   > >  Class<?> klass = str.getClass();

   > ②、判断是否为某个类的实例

10. 说说自定义注解的场景及实现

   ## 自定义注解使用场景

   1. 类属性自动赋值。
   2. 验证对象属性完整性。
   3. 代替配置文件功能，像spring基于注解的配置。
   4. 可以生成文档，像java代码注释中的@see,@param等

11. 列出自己常用的JDK包

    java.util.*,java.lang,java.io,java.sql,java.util,java.nio;

12. MVC设计思想

mvc(model view controller)
    (1)什么是mvc?
        是一种软件架构的思想，将一个软件按照模型、视图、控制器进行划分。其中，模型用来封装业务逻辑，视图用来实现表示逻辑，控制器用来协调模型与视图(视图要通过控制器来调用模型，模型返回的处理结果也要先交给控制器，由控制器来选择合适的视图来显示 处理结果)。
        1)模型: 业务逻辑包含了业务数据的加工与处理以及相应的基础服务(为了保证业务逻辑能够正常进行的事务、安全、权限、日志等等的功能模块)
        2)视图:展现模型处理的结果；另外，还要提供相应的操作界面，方便用户使用。

​        3)控制器:视图发请求给控制器，由控制器来选择相应的模型来处理；模型返回的结果给控制器，由控制器选择合适的视图。

![img](E:\mydairy\java基础\mvc模型.jpg)

    (2)为什么要使用mvc?
        1)使用mvc的思想来设计一个软件，最根本的原因是为了实现模型的复用:
            a,模型不用关心处理结果如何展现。
            比如，模型返回一些数据，然后交给不同的视图来展现(表格的方式、图形的方式等等)。
            b,可以使用不同的视图来访问同一个模型。
        2)代码的维护性更好
            修改模型不会影响到视图，反过来，修改视图，也不会影响到模型。
        3)方便测试
            比如，将业务逻辑代码写在servlet里面，需要部署到容器上，然后才能测试。而将业务逻辑代码写在java类里面，可以直接用main()测试（不依赖容器）。
    (3)如何使用mvc来开发一个web应用(javaee)。
        1)使用java类来实现模型，使用jsp来实现视图，使用servlet或者filter来实现控制器。
        注意：
        模型也可以使用一些企业级的Java组件，比如，ejb，spring容器管理的JavaBean来实现。
        视图也可以使用jsf，模板技术（freemarker等）。
        2)请求都发送给控制器(servlet),控制器依据请求的

        不同调用相应的模型(java类)来处理；模型返回的处理结果给控制器(servlet)，然后控制器选择合适的视图(jsp)来展现处理结果。

![img](E:\mydairy\java基础\MVC调用.jpg)

​    （4）mvc的缺点

   使用mvc，会增加代码量、相应地也会增加软件开发的成文，设计的难度也会增加。

13. equals与==的区别

    equals比较的是两个对象内存中的值的变量，==比较的是内存地址是否相等

14. hashCode和equals方法的区别与联系

    Object 对象中存在equals方法，默认比较的是两个对象的内存地址是否一样，当我们要判断两个对象是否相等（值相等时），通常需要重写equals方法，而不是直接比较内存地址。重写equals方法时，通常需要重写hashcode ,当该对象需要被存储在某散列容器上时，改容器的散列是通过hashcode来散列的，两个对象相同会有相同的hashcode,而不重写hashcode,就会使用默认的hashcode方法计算，即通过内存地址来计算。这样的话就不可以让相同的对象散列在同一个桶上。而且会产生很多隐藏的bug

15. 什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用

     我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输，但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java 帮我们做，要被传输的对象必须实现serializable接口，这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的。

16. Object类中常见的方法，为什么wait  notify会放在Object里边？

    简单说：因为synchronized中的这把锁可以是任意对象，所以任意对象都可以调用wait()和notify()；所以wait和notify属于Object。

    专业说：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒，不可以对不同锁中的线程进行唤醒。

    也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在object类中。

17. ·JDK和JRE的区别

     JDK（Java Development Kit）

    JDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。

    JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。

    JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。

18. Java 8有哪些新特性

    1. lambada表达式
    2. 接口可以有默认方法，静态方法
    3. 方法引用
    4. 重复注解
    5. base64编码支持
    6. concurrenthashmap改进，用synchronize +红黑树