# CVTE/1

##分布式锁实现原理

使用redis可实现分布式锁: 有两种实现方法

 **方法一：通过命令setnx(key,value)和expire(key)实现**

对需要共享的变量设置值，如果resis存在这个变量这设置不成功，否则设置成功

然后通过expire()设置该键的过期时间，主要是为了防止饿死的情况出现，当执行完业务忘记删除已经锁定的键会造成饿死的情形出现。

但是这种方法仍然不是决定安全的，如果当执行完expire()命令前，出现宕机，仍然会出现饿死的情况。

方法二：通过命令setnx(key,当前时间+过期时间)，get(),getset()

- setnx(key,过期时间)，如果成功，表示成功获得锁，否则转向下一步
- get(key)，得到key的过期时间，和当前时间进行判断，如果过期，表示允许其他线程使用，否则重复上述操作。
- 如果允许线程使用则对该key加上过期时间再使用，使用命令getset(),得到的时间是就的过期时间，与当前时间比较，如果比当前时间小，表示成功获得该锁并且已经设置了过期时间，否则重复上述步骤。
- 执行完业务逻辑时，记得手动删除key.让其他线程可以使用。

## get和post区别

两个都是想服务器发起请求，请求的方式不同

get请求的请求参数在url地址上，而post的请求参数在http协议的body上，因此，post请求相比get更加安全。

get请求的请求参数长度有限制不能太大，适合传输少量参数传输，post请求的请求参数无限制，可以处理请求参数较大的情况，因为参数是放在http协议的body中。

get适合查询数据，post适合上传下载数据

get产生一次TCP数据报，浏览器会把http头部和数据一起发送出去，服务器相应200

get产生2次TCP数据报，浏览器先发送请求头，服务器相应返回100 continue,浏览器在发送data,服务器响应200

get请求如果是静态资源会被浏览器主动cache,而post不会

get请求只能进入url编码，post支持多种编码

GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 

对于参数的数据类型，get只接受ASCLL	字符，而post没有限制

##消息队列了解

使用消息队列的理由：

请求太多，同步操作来不及完成，引入消息队列，对消息进行一步处理

优点

- 生产者把消息放入消息队列中，消费者从消息队列中取数据。生产者与消费者之间是异步进行的。
- 使用消息队列可以加快客户端的相应，将非必要的业务逻辑以异步的方式运行，加快响应速度。
- 削峰，当并发量大时，直接操作数据库会操作数据库崩溃。而使用消息队列，生产者把消息放入消息队列中，消费者按照一定的速度从消息队列中拉取信息并处理。在生产中，短暂的高峰积压是可以接受的

缺点：

- 系统的可用性能降低：一个原本运行好好的系统，是一个很正常的系统。引进了消息队列，如果消息队列挂了，那么整个系统就完蛋了。所有在引进一项技术时，要做好充分的评估，确保技术的高可用性。以及数据的安全性（消息队列是否成功送到消息队列，消息队列消息丢失了怎么办，消息队列如何确保成功被消费者消费等诸如此类的问题）
- 系统的负责性提高：意味着要考虑的方面变多，维护的成本增加。

如何确保消息队列的高可用

- 主从分布，master、slave,定期检测是否连通，心跳包检测。

如何确保消息不被重复消费

- 对于要插入输入库的数据，给插入的消息做一个唯一主键，就算重复消费的情况出现，那么插入数据时会出现主键冲突，拒绝插入，避免脏数据的产生
- 使用Redis来保存消费过的消息，给每个消息一个id,message,到消息来时校验消息是否在redis保存过，如果已经存在该消息表示是重复消息直接丢弃。否则放入redis中，设置一个合理的过期时间，或者定期清理redis上的消息。

如果保证消息的可靠性传输

- 借鉴TCP三次握手原理。向发送发回送一个ack.

关于消息队列消息丢失问题处理:

消息队列对接收到的消息进行持久化处理，然后回传告诉消费者已经确保不会丢失。即使宕机，重新启动也能恢复原先的消息。等接收到消费者确认消费的消息后就可以把消息从磁盘中删除。

如何确保消息的顺序性：

大部分业务都不需要确保消息的顺序性，少部分才需要，怎么来确保呢?

按照某种算法确保消息放进消息队列的顺序是有序的，使用一个消费者去消费就可以确保消息消费的顺序性。

至于多消费者消费的情况下，可以在客户端实现，a类消息必须等待b类消息被消费才能进行，否则就等待。这样就可以确保消费的有序性



## AOP和DI介绍

AOP就是面向切面编程，可以把原本散落在业务逻辑的重复的代码封装成可重用的模块，在spring 中叫做切面，使用切面的方法只需进行方法的切面声明即可，可以通过配置文件配置，也可以通过注解声明。这样做的好处可以大大减少重复性的代码，减低代码的耦合度，系统的可维护性更高。

实验原理：使用动态代理的方式来实现。在spring启动时，声明了切片方法的类会生成一个代理类，代理类有一个invoke方法，method.invoke执行的是原方法。在该方法调用前或者后可以插入需要执行的切面方法。这个过程的实现是通过动态代理来完成的。程序运行时动态的生成对应类的代理类，当用户调用该方法时会调用其代理方法为其执行，生成的类具有相当的接口，代理实例赋值给原类。所有调用原类的方法实际上是调用代理类的方法。

DI：也就是依赖注入，spring启动是，实例对象的依赖对象会相应的被注入进来，这整个注入过程对用户的透明的，由spring 来完成，无需用户关心。作用是可以降低系统的耦合性，需要的时候才注入。注入过程由spring管理。实现了依赖的解耦。

实现的原理是通过反射来是实现的。spring 启动时，spring 读取配置文件，解析保存配置信息，得到相应的beandefinition存储起来。里面包含了bean 的全部定义。到需要注入时，通过获取beandefinition知道该bean的信息，然后通过反射生成实例对象，返回对象的引用给要注入的对象，实现依赖注入。

## jdk动态代理与Cglib动态代理的区别

jdk动态代理只能对实现了接口的类进行代理，而不能针对类本身

CGLIB是针对类来进行动态代理的，通过一个子类继承代理类的，然后覆盖子类的其中的方法来实现动态代理。

jdk1.7后jdk动态代理的执行效率比cglib的执行效率要高大概百分之20.所以优先考虑使用jdk动态代理的方式。

## 单例模式的几种实现方式 

单例模式分为2两种：饿汉模式，懒汉模式。

饿汉模式：在类加载时进行了实例对象的生成，因此类加载相对懒汉慢

优点：线程安全，第一次获取对象快。

懒汉模式：第一次获取实例对象时经常实例对象创建。

线程不安全，类加载相对较快。第一次获取对象慢。

可以通过加锁来实现线程安全。

## sql优化 

查询数据时使用索引，多使用组合索引，使用索引时要遵循最左前缀匹配规则。

在排序时可以利用索引来加快排序。

尽量少用select *的查询语句。

进来不要对索引进行主动或者自动的类型转换，否则会导致索引失效。

通配符不要放在字符的首部，否则会导致索引失效

不要在索引上进行函数运算，否则会导致索引失效

避免在索引上是有is null,is not null,否则会导致索引失效

用EXISTS替代IN、用NOT EXISTS替代NOT IN （exists的效率要比in的效率高）

不要创建分辨度不高的索引。如性别。

建立的索引是要经常用做查询条件的字段

建立索引的优点：

- 创建唯一索引可以保证数据的唯一性
- 大大加快数据的检索速度
- 可以显著检索分组和排序的时间

缺点：

- 索引需要占据数据表以外的物理空间
- 创建和维护索引需要花费一定的时间
- 当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度