## 锁汇总

## 悲观锁

悲观锁，正如其名，具有强烈的独占性和排他性。被加锁的数据不允许外部访问（包括读写），如果加锁时间过长，其它用户长时间不能访问，影响程序的并发访问性，同样对数据库性能产生很大的开销，特别是长事务，这样的开销往往是无法承受的。

## 乐观锁

步骤分为三步：数据读取，数据校验，数据写入。

乐观锁：理想认为对某事务锁竞争不激烈，采用较为宽松的加锁机制，通常使用CAS的方法实现，顾名思义比较并交换，比较的时候如果与期待值一样，则进行写入。否则重复比较并交换的过程，直到完成。在数据库中常常使用版本号来标识数据在写入前是否被更改过，从而实现数据库在无锁的情况下保证数据的安全性。

## 分布式锁

在分布式的集群中，对锁接口的QPS通常要求很高，单台服务器服器无法实现，需要使用redis,统一管理锁资源。

在单机的情况下，可以通过线程共享内存来实现线程之间的加锁，但是在分布式的集群下，多个线程就可能在不同的机器上，共享内存的方式就无法满足要求。这就是为什么使用Redis的原因。使用redis 实现分布式锁的方式有以下两种

- ### 使用redis的setnx()、expire()方法

  使用分布式锁要注意设置锁定数据的过期时间，这样能够有效的避免死锁

  说明以下setnx()命令，setnx()的含义是set if Not exists,其中有两个参数setnx(key,value),该方法是原子性的，设置成功返回1，否则返回0，但是设置过期时间需要使用expire(key,time)来对Key设置

  具体执行过程：

  1. setnx(lockkey,1) 如果成功返回1，表示成功，否则返回0，失败
  2. expire()命令对lockkey 进行设置过期时间
  3. 执行完业务需要手动通过delete命令删除key键

  这样方法并不意味着绝对的安全，当expire()设置成功前，发生了宕机，仍然有机会存在发生死锁的情况。可以使用以下方法redis 的setnx(),get(),

  和getset()方法来实现分布式锁  

- ### 使用redis的setnx()、get()、getset()方法

  这个方案是上述方案的优化

  getset(key,value) 方法返回oldvalue,操作是原子性的

  具体步骤

  - setnx(lockkey,当前时间+过期时间) 如果返回1，则获取成功，如果返回0则获取失败
  - get(lockkey) 获取到当前oldExpireTime,并将这个值和当前系统时间进行比较，如果比系统时间小说明此键已经过期，可以允许其他线程使用
  - 计算newExpireTime=当前时间+过期时间，然后getset(lockkey),会返回一个当前的过期时间，与上一次get操作的过期时间比较，如果一致，说明操作成功，否则重复上述操作。
  - 在业务处理完成后。如果锁还没过期，主动删除lockkey,给其它线程使用

## 可重入锁

可重入锁又叫递归锁，是指已经获得某锁的对象可以重复获得该锁，在锁实现的内部事务count来计算相同的锁被同一对象获得了多少次，当任一个锁释放时，count--，当count=0时，才真正的把锁释放。同样synchronized也是可重入锁，可重入锁的好处是可以避免事务，否则就会出现自己等待的资源自己持有又在等待释放，自相矛盾造成死锁

## 自旋锁

自旋锁是采用让当前线程不停地在循环体中执行，当循环体的条件被其它线程改变时，进入临界区

自旋锁是将当前线程不断地执行循环体，不进行线程状态的改变，所有相应更快。当线程数增加，因为每个线程都在执行，会占用CPU资源，性能会明显下降。如果线程竞争不激烈，并且保存锁的时间短，适合使用自旋锁。

## 独享锁

独享锁是指该锁一次只能被一个线程锁持有（ReentrantLock,Synchromized都是独享锁）

## 共享锁

共享锁是指该锁可以被多个线程占有，如读锁是共享锁

## 阻塞锁

阻塞锁，可以说 是让线程进入阻塞状态等待，当获得了相应信号(唤醒，时间到了)时，才可以进入线程的准备就绪阶段，准备就绪的所有线程，通过竞争，进入运行状态。



  

  


