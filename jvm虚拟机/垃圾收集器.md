#垃圾收集器

##CMS收集器

CMS收集器是一种以获取最短回收停顿时间为目的的收集器

CMS收集器是基于“标记清除”算法实现的。

整个过程分为4个步骤

- 初始标记
- 并发标记
- 重新标记
- 并发清除

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”.初始标记仅仅标记一下GC Root能直接关联的对象。速度很快

并发标记阶段就是GC Roots Tracing的过程，而重新标记阶段就是为了修正并发标志期间因用户程序继续运作而导致标志产生表动的那一部分的标记记录。这个阶段的停顿时间一般会比初始标记阶段稍微长一些。当远比并发标记时间短

由于整个过程消耗最长的并发标志和并发清除过程收集器线程可以和用户线程一起工作，所以，从总体来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

CMS是一款优秀的收集器，他的主要优点是：并发收集，低停顿

缺点：

CMS收集器对CPU资源非常敏感。在并发阶段，收集器会占用一部分线程或者CPU资源而导致应用进程变慢，总的吞吐率下降。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是说当CPU数量大于4以上，并发收集线程不少于百分之25的资源，并且随着CPU数量的增加而下降。当是当CPU不足4比如2个，CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一般的运算能力去执行收集器线程，就可能导致用户线程的执行速度忽然降低到50%，其实是让人难以接受的。

CMS收集器无法处理浮动垃圾，可能不想“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾产生，这部分垃圾出现在标记过程之后，CMS无法在当次就处理调他们。只好留到下一次GC时在清理，这部分垃圾就是“浮动垃圾”。

CMS是基于“标志清除”算法实现的，垃圾收集完毕会出现垃圾碎片，如果收集完进行碎片整理，就会加大停顿时间。所有一般多次收集后再进行一次碎片整理。



# G1收集器

步骤

-  初始标记
- 并发标志
- 最终标记
- 筛选回收